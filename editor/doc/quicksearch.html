<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Modules × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Data-to-Music APIA browser-based JavaScript API for real-time data sonification. Try the interactive editor with documentations. How to useLoad the library into your web application as a global variable dtm by including dtm.js or dtm.min.js in the HTML file. &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello DTM&lt;/title&gt; &lt;script src=&quot;dtm.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var a = dtm.data(1,2,3,4,5); dtm.music().note(a.range(60,90)).play(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;See the tutorials in documentation as well as the modules dtm.data and dtm.music for more details. BuildingDependencies:Node.js and NPMBower (browser dependency management)Grunt (task automation)Karma and Jasmine (unit testing)JSDoc (documentation builder) CreditsOpen-source libraries used in the DTM API:Kiss FFT × Search results Close "},"module-core.html":{"id":"module-core.html","title":"Module: core","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Module: core Members dtm :object A namespace / the singleton dtm object. Type: object × Search results Close "},"module-data.html":{"id":"module-data.html","title":"Module: data","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Module: data dtm.data provides analysis, transformation, and some unusual modulation methods. It can be passed to most of the parameters of dtm.music object as well as other instances of dtm.data. Methods &lt;static&gt; data() Returns a new single-dimensional array-like object with various transformation functions. Returns: array object Type Object Examples // Create a new data object with initial values. var a = dtm.data(1, 2, 3); // Create an empty data object. var a = dtm.data(); a.set(1, 2, 3); &lt;static&gt; augment(fnList) Adds new function(s) to the dtm.data prototype. Using existing function name overwrites the old one. Parameters: Name Type Description fnList Object An object with one or more custom functions and optional alias definitions. Example dtm.data.augment({ // (Optional) Sets alternate function names. aliases: { magtodb: ['mag2db', 'm2db'] }, // A custom function to convert magnitude values (in the range of [0, 1]) to dB full scale. magtodb: function () { // &quot;this&quot; is the data object itself. You should return it to enable the method chaining. return this.map(function (d) { // The map function takes each value in the array and sets an altered value that is returned. Note that each value is also encapsulated in a dtm.data object, allowing you to use the existing dtm.data methods. If you want to work with raw values, use the mapvalue function instead. return d.log(10).mult(20); }); } }); // Use the custom function. dtm.data(0, 0.5, 1).magtodb().print() -&gt; [-Infinity, -6, 0] each(fn) Performs JS Array.forEach function to the array values. Parameters: Name Type Description fn Returns: Type dtm.data map(fn) Iteratively processes each item in the data object. Similar to JS Array.prototype.map, though the first callback argument is wrapped in a dtm.data object. To work on raw values, you can use mapvalue function instead. Parameters: Name Type Description fn function A callback function. The arguments are datum (dtm.data object), index (integer), self (dtm.data object). Returns: Type dtm.data Example dtm.data(1,2,3).map(function (datum, index, self) { return datum.mult(2); // You must return each result to update the values in the array. }).print(); -&gt; [2, 4, 6] block | b(len, hop, window, tail) Parameters: Name Type Description len hop window tail Returns: Type dtm.data unblock | ub | flatten() Returns: Type dtm.data fit(len [, interp]) Stretches or shrinks the length of the array into the specified length. Parameters: Name Type Argument Default Description len number Integer interp string &lt;optional&gt; 'linear' Returns: Type dtm.data stretch(factor [, interp]) Multiplies the length of the array by the given factor. Parameters: Name Type Argument Default Description factor number interp string &lt;optional&gt; 'linear' Returns: Type dtm.data fft() set() Sets or overwrites the contents of the data object. Returns: Type dtm.data get( [param]) Returns the array contents or an analyzed value Parameters: Name Type Argument Description param string | number &lt;optional&gt; If no argument is given, returns the array content. If given a number, returns the value at the index. If given a valid string, the value / stats / etc. is returned. Possible string keys are as follows: name|key, type, len|length, min|minimum, max|maximum, minmax|range, mean|avg|average, mode, median, midrange, std, pstd, var|variance, pvar, rms, cur|current|now, next, pver|previous, rand|random, idx|index, hop|step|stepSize, loc|location|relative, block|window (with 1|2 following numbers), blockNext, original, normal|normalize|normalized, sort|sorted, uniq|unique|uniques, classes, classID, string|stringify, numClasses|numUniques, unif|uniformity, histo|histogram Returns: Type number | array | string len() Returns: Type dtm.data clone() Returns a copy of the array object. It can be used when you don't want to reference the same array object from different places. For convenience, you can also do obj() instead of obj.clone() to quickly return a copy. Returns: Type dtm.data name(name) Sets the name of the array object. Parameters: Name Type Description name string Returns: Type dtm.data save() Overwrites the &quot;original&quot; state with the current state. Using data.residue(), data.snr(), etc. measures the distance between the current state and the saved state. Returns: Type dtm.data Example var a = dtm.data(1, 2, 3); a.line(10).save(); reset() Retrieves the original values from when the array object was first created. Returns: Type dtm.data residue | res() Returns: Type * | dtm.data clear | flush() Clears all the contents of the array object. Returns: Type dtm.data mapvalue | mapv | mv(fn) Parameters: Name Type Description fn Returns: Type dtm.data eachvalue | eachv | ev(fn) Parameters: Name Type Description fn Returns: Type dtm.data column | col() Returns a dtm.data containing a copy / copies of the source at specified index. The copies may be a single value or a n-dimensional array, depending on the dimensionality of the source dtm.data. Aliases: col(), varaible() (i.e., calling the dtm.data object itself as a function). Returns: Type dtm.data select | sel | at() Returns: Type select row(num) Returns a row of a nested array by the index, as opposed to the default behavior of returning columns with data(indices). Parameters: Name Type Description num Returns: Type dtm.data interpolate | interp | itp(at, mode) Estimates a value / values using fractional indices. Parameters: Name Type Description at mode Returns: Type dtm.data phase | p | scan(at, mode) Return an interpolated value(s) at specified phase, a countinous value between 0 and 1. If the phase goes below or above this range, it wraps around. Parameters: Name Type Description at mode Returns: Type phase mphase | mp(at, mode) A mirrored-phase function. Going above the phase of 1, for example, will result in reading the data backwards. Parameters: Name Type Description at mode Returns: Type mphase range | r(arg1, arg2 [, arg3] [, arg4]) Modifies the range of the values. If the domain values are unspecified, the input is normalized to produce the full range between the specified minimum and maximum values. Parameters: Name Type Argument Description arg1 number | array | dtm.data The target minimum value of the scaled range. arg2 number | array | dtm.data The target maximum value of the scaled range. arg3 number &lt;optional&gt; The minimum of the domain (original) value. arg4 number &lt;optional&gt; The maximum of the domain value. Returns: Type dtm.data Example // Specifying the output range dtm.data([1, 2, 3]).range([0, 10]).get(); // or dtm.data([1, 2, 3]).range(0, 10).get(); -&gt; [0, 5, 10] // Specifying the domain values (the second array in the argument) dtm.data([1, 2, 3]).range([0, 10], [0, 5]).get(); // or dtm.data([1, 2, 3]).range(0, 10, 0, 5).get(); -&gt; [2, 4, 6] normalize | n( [arg1] [, arg2]) Rescales the range of numerical values to 0-1. Parameters: Name Type Argument Description arg1 number &lt;optional&gt; Prefered domain minimum value. If not present, the minimum of the input array is used. arg2 number &lt;optional&gt; Prefered domain maximum value. If not present, the maximum of the input array is used. Returns: Type dtm.data unipolar | uni | up() Rescales the range to be between 0 and 1. Returns: Type dtm.data bipolar | bi | bp(dc) Rescales the range to be between -1 and 1. Parameters: Name Type Description dc Returns: Type dtm.data limit | clip( [min] [, max]) Caps the array value range at the min and max values. Only works with a numerical array. Parameters: Name Type Argument Default Description min &lt;optional&gt; 0 max &lt;optional&gt; 1 Returns: Type dtm.data expcurve | expc | ec(factor [, min] [, max]) Scales the array with an exponential curve. Parameters: Name Type Argument Default Description factor number min number &lt;optional&gt; data.get('min') max number &lt;optional&gt; data.get('max') Returns: Type dtm.data logcurve | logc | lc(factor [, min] [, max]) Applies a logarithmic scaling to the array. Parameters: Name Type Argument Default Description factor number min number &lt;optional&gt; data.get('min') max number &lt;optional&gt; data.get('max') Returns: Type dtm.data curve | c(factor, min, max) A combination of the expcurve and logcurve functions. At factor 0, there would be no change. A positive factor gives a logarithmic scaling, while a negative factor gives an exponential scaling. Parameters: Name Type Description factor min max Returns: Type dtm.data linear | line | l(len) A shorthand for data.fit(&quot;line&quot;, params). Parameters: Name Type Description len Returns: Type dtm.data step(len) Parameters: Name Type Description len Returns: Type dtm.data cosine | cos(len) Parameters: Name Type Description len Returns: Type dtm.data cubic | cub(len) Parameters: Name Type Description len Returns: Type dtm.data slinear | sline | sl(factor) A shorthand for data.stretch(&quot;linear&quot;, params) Parameters: Name Type Description factor Returns: Type dtm.data sstep(factor) Parameters: Name Type Description factor Returns: Type dtm.data scosine | scos(factor) Parameters: Name Type Description factor Returns: Type dtm.data scubic | scub(factor) Parameters: Name Type Description factor Returns: Type dtm.data fitsum | fs | total(tgt [, round]) Scales the values so that the sum fits the target value. Useful, for example, for fitting intervallic values to a specific measure length. Parameters: Name Type Argument Default Description tgt number If the round argument is true, the target value is also rounded. round boolean &lt;optional&gt; false Returns: Type dtm.data morph(tgtArr [, morphIdx] [, interp]) Morphs the array values with a target array / dtm.data values. The lengths can be mismatched. Parameters: Name Type Argument Default Description tgtArr array | dtm.data morphIdx number &lt;optional&gt; 0.5 between 0-1 interp string &lt;optional&gt; 'linear' Returns: Type dtm.data window | win(type) Applies a window function to the array. May be combined with array.block() operation. Parameters: Name Type Description type Returns: Type dtm.data ola(hop) Flattens a 2-dimensional dtm.data using the overlap-and-add method. Parameters: Name Type Description hop Integer Returns: Type dtm.data copy(times) Parameters: Name Type Description times Returns: Type copy transp | t() amp | am | gain(input) Parameters: Name Type Description input Number | Array | dtm.data Returns: self Type dtm.data freq | fm(input) Parameters: Name Type Description input Number | Array | dtm.data Returns: self Type dtm.data add | plus(factor [, interp]) Adds a value to all the array elements. Parameters: Name Type Argument Default Description factor number | array | dtm.data interp string &lt;optional&gt; 'step' Returns: Type dtm.data Example dtm.data(1, 2, 3).add(10).print(); -&gt; [11, 12, 13] subtract | minus(factor, interp) Parameters: Name Type Description factor interp Returns: self Type dtm.data multiply | mult(factor [, interp]) Scales the numerical array contents. Parameters: Name Type Argument Default Description factor number | array | dtm.data interp string &lt;optional&gt; 'step' Returns: Type dtm.data divide | div(factor, interp) Parameters: Name Type Description factor interp Returns: self Type dtm.data reciprocal | recip(numerator) Parameters: Name Type Description numerator Returns: self Type dtm.data power | pow | exp(factor [, interp]) Parameters: Name Type Argument Default Description factor number | array | dtm.data interp string &lt;optional&gt; 'linear' Returns: Type dtm.data powerof | powof(factor [, interp]) Applies the array contents as the power to the argument as the base Parameters: Name Type Argument Default Description factor number | array | dtm.data interp string &lt;optional&gt; 'linear' Returns: Type dtm.data log(base, interp) Parameters: Name Type Description base interp Returns: self Type dtm.data round | quantize | q(to) Rounds float values of the array to integer values. Parameters: Name Type Description to number Returns: Type dtm.data floor() Quantizes float numbers to integer by flooring. Returns: Type dtm.data ceil() Quantizes float numbers to integer by ceiling. Returns: Type dtm.data abs | fwr() Full-wave rectify the values, returning absolute values. Returns: Type dtm.data hwr() Half-wave rectify the values, modifying all negative values to 0. Returns: Type dtm.data modulo | mod(divisor) Parameters: Name Type Description divisor Returns: Type * morethan | mt(val) Parameters: Name Type Description val Returns: Type morethan mtet(val) Parameters: Name Type Description val Returns: Type mtet lessthan | lt(val) Parameters: Name Type Description val Returns: Type lessthan ltet(val) Parameters: Name Type Description val Returns: Type ltet has() Returns: Type boolean min(fn) Parameters: Name Type Description fn Returns: self Type dtm.data max(fn) Parameters: Name Type Description fn Returns: self Type dtm.data extent() Returns: self Type dtm.data mean | avg(fn) Parameters: Name Type Description fn Returns: self Type dtm.data mode(fn) Parameters: Name Type Description fn Returns: self Type dtm.data median(fn) Parameters: Name Type Description fn Returns: self Type dtm.data midrange | mid(fn) Parameters: Name Type Description fn Returns: self Type dtm.data centroid(fn) Parameters: Name Type Description fn Returns: self Type dtm.data std(fn) Parameters: Name Type Description fn Returns: self Type dtm.data pstd(fn) Parameters: Name Type Description fn Returns: self Type dtm.data var(fn) Parameters: Name Type Description fn Returns: self Type dtm.data pvar(fn) Parameters: Name Type Description fn Returns: self Type dtm.data rms(fn) Parameters: Name Type Description fn Returns: self Type dtm.data sum() Returns: self Type dtm.data accumulate | accum | cuml | cum() Returns: self Type dtm.data diff() Returns: Type dtm.data mse() Calculates the mean-square-error. If no argument is given, it will take the current array state as the modified value, and calculates the distortion from the original (initial state) value of itself. This would be useful for choosing quantization or transformation methods with less distortion to the data. Returns: Type dtm.data snr() Returns: self Type dtm.data dbsnr() Returns: self Type dtm.data dct() Returns: self Type dtm.data idct() Returns: self Type dtm.data fir() Returns: self Type dtm.data amdf() Returns: self Type dtm.data correlation | corr() Returns: self Type dtm.data covariance | covar | cov() Returns: self Type dtm.data linreg() Returns: self Type dtm.data histogram | histo | hist() Generates a histogram from a nominal array, such as the string type. Returns: Type dtm.data count() Returns: self Type dtm.data mapcount() Returns: self Type dtm.data distribution | dist() Distribution of each symbol (unique value) Returns: Type dtm.data mapdist() Returns: self Type dtm.data pmf() Returns: self Type dtm.data cdf() Cumulative distribution function Returns: Type dtm.data invert() Returns: self Type dtm.data icdf() Returns: self Type dtm.data entropy() Returns: self Type dtm.data unique | uniq() Overwrites the contents with unsorted unique values of the array. Returns: Type dtm.data classify | class(by) Parameters: Name Type Description by Returns: Type dtm.data shuffle | randomize() Randomizes the order of the array. Returns: Type dtm.data randomtrigger | randtrig(dist) Parameters: Name Type Description dist Returns: Type randomtrigger mtof() Returns: self Type dtm.data ftom() Returns: self Type dtm.data freqtomel() Returns: self Type dtm.data meltofreq() Returns: self Type dtm.data notesToBeats | ntob( [resolution]) Converts note values into a beat sequence. Parameters: Name Type Argument Default Description resolution number &lt;optional&gt; 4 Returns: Type dtm.data beatsToNotes | bton( [resolution]) Converts beat sequence into note values. Parameters: Name Type Argument Default Description resolution number &lt;optional&gt; 4 Returns: Type dtm.data intervalsToBeats | itob() Converts intervalic values into a beat sequence. Returns: Type dtm.data beatsToIntervals | btoi() Converts beat sequence into intervalic values. Returns: Type dtm.data intervalsToOffsets | itoo() Returns: self Type dtm.data offsetsToIntervals | otoi() Converts time offset sequence (e.g., [0, 0.5, 1, etc.], usually in seconds) to intervallic sequence that may signify note durations. Since we don't have the information about the duration of the very last note, it is copied from the one before that. Returns: Type offsetsToIntervals beatsToTime | btot() Converts beat sequence into an array of indices (or delays or onset-coordinate vectors.) Useful for creating time delay-based events. Returns: Type dtm.data timeToBeats | ttob( [len]) Parameters: Name Type Argument Description len &lt;optional&gt; Returns: Type dtm.data tonumber | tonum | num() Converts string or boolean values to numerical values. Returns: Type dtm.data stringify | tostring() Converts the array values (such as numbers) into string format. Returns: Type dtm.data toFloat32 | tofloat32 | tf32() Returns: self Type dtm.data reduce(fn) Parameters: Name Type Description fn some(fn) Parameters: Name Type Description fn every(fn) Parameters: Name Type Description fn Returns: Type boolean fileter(fn) Parameters: Name Type Description fn concat | cat | append | app(arr) Concatenates new values to the contents. Parameters: Name Type Description arr array | dtm.data A regular array or a dtm.data object. Returns: Type dtm.data prepend | prep(arr) Parameters: Name Type Description arr repeat | rep(count) Repeats the contents of the current array. Parameters: Name Type Description count number Integer Returns: Type dtm.data fitrepeat | fitrep | frep(count, interp) Parameters: Name Type Description count interp pad(val, length) Parameters: Name Type Description val length Returns: Type Object truncate(arg1 [, arg2]) Truncates some values either at the end or both at the beginning and the end. Parameters: Name Type Argument Description arg1 number Start bits to truncate. If the arg2 is not present, it will be the end bits to truncate. arg2 number &lt;optional&gt; End bits to truncate. Returns: Type dtm.data remove(input) Parameters: Name Type Description input removeempty() shift(amount) Shifts the indexing position of the array by the amount. Parameters: Name Type Description amount number Integer Returns: Type dtm.data mirror | mirr | mir() Appends an reversed array at the tail. Returns: Type Object reverse | rev() Flips the array contents horizontally. Returns: Type dtm.data flip( [center]) Flips the numerical values vertically at the given center point. Parameters: Name Type Argument Default Description center number &lt;optional&gt; meanVal Returns: Type dtm.data queue | fifo(input) Adds new value(s) at the end of the array, and removes the oldest value(s) at the beginning of the array. The size of the array is unchanged. Parameters: Name Type Description input number | array Returns: Type dtm.data find(tgt) Parameters: Name Type Description tgt Returns: Type dtm.data sort() Sorts the contents of numerical array. Returns: Type dtm.data sortby(fn, desc) Parameters: Name Type Description fn desc replace(tgt, val) Parameters: Name Type Description tgt val Returns: Type dtm.data reorder | order() split( [separator]) Separates the array items into new array using the separator Parameters: Name Type Argument Default Description separator string &lt;optional&gt; '' Returns: dtm.data join(delimiter) Parameters: Name Type Description delimiter editdit(target) Parameters: Name Type Description target Returns: Type editdist call(fn) Parameters: Name Type Description fn Returns: Type dtm.data process(fn) Parameters: Name Type Description fn Returns: Type process print() Returns: Type print plot() Returns: Type plot pitchquantize | pq(scale) Pitch quantize the array values. Shorthand: data.pq Parameters: Name Type Description scale array | dtm.data A numerical or string (solfa -- e.g., 'do' or 'd' instead of 0) denoting the musical scale degrees. Returns: Type dtm.data note() interleave(arrIn [, depth1] [, depth2]) Interleaves two arrays Parameters: Name Type Argument Default Description arrIn dtm.data depth1 number &lt;optional&gt; 1 Must be an integer depth2 number &lt;optional&gt; 1 Must be an integer Author: Ben Taylor Returns: Type dtm.data × Search results Close "},"module-loader.html":{"id":"module-loader.html","title":"Module: loader","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Module: loader Data object. Extends the dtm.data class, storing a multi-dimensional array. Methods &lt;static&gt; load( [input], fn) Creates a new dtm.data (array) object, if the argument is empty, or a promise object, if the argument is a URL. Parameters: Name Type Argument Description input string &lt;optional&gt; URL to load or query the data fn function Returns: Type dtm.data | promise &lt;static&gt; csv(input, fn) Parameters: Name Type Description input fn &lt;static&gt; text | txt(input, fn) Parameters: Name Type Description input fn &lt;static&gt; web(url, fn) Parameters: Name Type Description url fn &lt;static&gt; image | img | pic(input, fn, mode) Parameters: Name Type Description input fn mode &lt;static&gt; cam(input, interval) Parameters: Name Type Description input interval &lt;static&gt; audio(grab, block) Parameters: Name Type Description grab block &lt;static&gt; wav(input, fn) Parameters: Name Type Description input fn × Search results Close "},"module-music.html":{"id":"module-music.html","title":"Module: music","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Module: music Some building blocks for model creation. It can be used as one-shot as well. Methods &lt;static&gt; music() Returns a new instance of music object. Returns: Type dtm.music Example var m = dtm.music(); m.play(); &lt;static&gt; offline(bool) Enable the offline-rendering mode. Most of the real-time behaviors should not changes. This mode may not be memory optimal in some browsers such as Chrome. Parameters: Name Type Description bool Example dtm.music.offline(true); // Turn on the offline mode. init() Returns: Type Music size | len(val) Sets the size of the wavetable. Parameters: Name Type Description val Integer Size in integer. Should be bigger than 0. Returns: self Type dtm.music Example dtm.music().size(8).play(); clone() Creates and returns a clone of the music object at the current state. Returns: Type dtm.music Example var a = dtm.music().note(72).amp(0.3); var b = a.clone().play(); a.note(84).play(); // This will not affect the state of the object `b`. get(param) Returns parameters Parameters: Name Type Description param Returns: Type * play | p() Plays a synthesized sound. Returns: Type dtm.music Example dtm.music().play(); start() Repetitively plays sound. Returns: Type dtm.music Example dtm.music().start(); trigger | trig | t() Triggers itself (including the registered callback functions) after a certain time delay. Returns: Type Music.t run | r() Returns: Type Music.r stop | s( [time]) Stops the currently playing sound. Parameters: Name Type Argument Default Description time number &lt;optional&gt; 0 Delay in seconds for the stop action to be called. Returns: Type dtm.music after | aft | offset() Returns: Type Music.offset mute(bool) Parameters: Name Type Description bool Returns: Type Music unmute() Returns: Type Music sync | follow() Returns: Type Music.follow mimic(input) Parameters: Name Type Description input Returns: Type Music each | do | on | onnote() Returns: Type Music.onnote offnote | off() Returns: Type Music.offnote sequence | seq() Returns: Type Music.seq iter | incr() Returns: Type Music.incr phase | scan() Returns: Type Music.phase repeat | rep() Returns: Type Music.rep every | at | interval | int | i() Sets the interval in seconds between repeated or iterated events. Returns: Type Music.i bpm() Returns: Type Music time() Returns: Type Music for | duration | dur | d() Takes array types with only up to the max depth of 1. Returns: Type dtm.music amplitude | amp | a() Returns: Type dtm.music frequency | freq | f() Sets the frequency of the oscillator Returns: Type dtm.music notenum | note | nn | n() Sets the pitch of the oscillator by a MIDI note number. Returns: Type dtm.music pitch() Returns: Type Music pan() Returns: Type Music waveform | wave | wf | wavetable | wt | w | osc() Returns: Type Music.wavetable sample | load() Returns: Type Music.load gain(mult, post) Parameters: Name Type Description mult post Returns: Type dtm.music lpf(freq, q, post) Parameters: Name Type Description freq q post Returns: Type dtm.music hpf(freq, q, post) Parameters: Name Type Description freq q post Returns: Type dtm.music bpf(freq, q, post) Parameters: Name Type Description freq q post Returns: Type dtm.music apf(freq, q, post) Parameters: Name Type Description freq q post Returns: Type dtm.music delay(mix, time, feedback, post) Parameters: Name Type Description mix time feedback post Returns: Type dtm.music reverb | verb() Returns: Type Music.verb convolve | conv() Returns: Type Music.conv bitquantize | bq(bit) Parameters: Name Type Description bit Returns: Type dtm.music samphold | sh(samps) Parameters: Name Type Description samps Returns: Type dtm.music monitor(input, block) Parameters: Name Type Description input block Returns: Type Music process(input, block) Parameters: Name Type Description input block Returns: Type Music phasor | curve() Returns: Type Music.phasor × Search results Close "},"module-utils.html":{"id":"module-utils.html","title":"Module: utils","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop Module: utils These utility functions are mainly used within DTM API for development. However, you can call them like: dtm.util.name(). Methods &lt;inner&gt; isEmpty(value) Returns true for undefined, null, and NaN values Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isNumber(value) Returns true if the value is a number and is not NaN Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isInteger(value) Checks if the value is a number and is an integer value Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isString(value) Checks if the value is a string Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isBoolean(value) Checks if the value is a boolean value Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isFunction(value) Checks if the value is a function Parameters: Name Type Description value Returns: Type boolean &lt;inner&gt; isPromise(obj) Checks if the value is an instance of Promise Parameters: Name Type Description obj Returns: Type boolean &lt;inner&gt; isObject(val) Checks if the value is an object and not null object Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isSingleVal(val) Checks if the value is primitive single value Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isFloat32Array(val) Checks if the value is a Float32Array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isNumArray(val) Checks if the value is a regular number array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isParsableNumArray(val) Checks if the object is a string array with values like ['1', '2', '3.45'] Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isObjArray(val) Checks if the array consists of the generic object type (i.e., {}) items Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isNumOrFloat32Array(val) Checks if the value is either a regular or typed number array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isMixedArray(val) Checks if the value is an array with mixed value types (e.g., numbers and strings mixed) Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isNestedArray(val) Checks if the value is a multi-dimensional array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isNestedWithDtmArray(val) Checks if the value is a nested (regular) array consist of the dtm.array instances Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isDtmObj(val) Checks if the value is an instance of DTM object Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isDtmArray(val) Checks if the value is an instance of dtm.array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isNestedDtmArray(val) Checks if the value is an instance of dtm.array with children dtm.arrays Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isStringArray(val) Checks if the value is a string array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; isBoolArray(val) Checks if the value is a boolean array Parameters: Name Type Description val Returns: Type boolean &lt;inner&gt; hasMissingValues(array) Checks if the given array has any &quot;empty&quot; values Parameters: Name Type Description array Returns: Type boolean &lt;inner&gt; argsToArray(args) Converts the arguments object into a regular array Parameters: Name Type Description args object The arguments object of the caller function Returns: Type Array &lt;inner&gt; argsForEach(args, fn) Iterates over the arguments object of the caller function Parameters: Name Type Description args object The arguments object fn function A callback function with same arguments of Array.forEach &lt;inner&gt; argIsSingleArray(args) Checks if the arguments object consist of a single array item Parameters: Name Type Description args object The arguments object Returns: Type boolean &lt;inner&gt; toFloat32Array(src) Converts various number or array types into a Float32Array. Returns null if not convertible. Parameters: Name Type Description src Returns: Type Float32Array | null &lt;inner&gt; getMin(arr) Returns the minimum value of numeric array. Parameters: Name Type Description arr number Returns: Type number &lt;inner&gt; getMax(arr) Returns the maximum value of numeric array. Parameters: Name Type Description arr number Returns: Type number &lt;inner&gt; mean(arr) Returns the mean of a numeric array. Parameters: Name Type Description arr array Input numerical array. Returns: val Single mean value. Type number Example dtm.transform.mean([8, 9, 4, 0, 9, 2, 1, 6]); -&gt; 4.875 &lt;inner&gt; mode(arr) Returns the most frequent value of the array. Parameters: Name Type Description arr array Returns: Type value &lt;inner&gt; median(arr) Returns the median of numerical array. Parameters: Name Type Description arr Returns: Type number &lt;inner&gt; midrange(arr) Returns the midrange of numerical array. Parameters: Name Type Description arr Returns: Type number &lt;inner&gt; sum(arr) Simple summation. Parameters: Name Type Description arr Returns: Type number &lt;inner&gt; variance(arr) Variance. Parameters: Name Type Description arr Returns: Type * &lt;inner&gt; std(arr) Standard Deviation. Parameters: Name Type Description arr Returns: Type * &lt;inner&gt; pvar(arr) Population Variance. Parameters: Name Type Description arr Returns: Type * &lt;inner&gt; pstd(arr) Population Standard Deviation. Parameters: Name Type Description arr Returns: Type number &lt;inner&gt; rms(arr) Root-Mean-Square value of given numerical array. Parameters: Name Type Description arr array Returns: rms Type number &lt;inner&gt; histo(input) Counts occurrences of each class in the list. Parameters: Name Type Description input array Returns: Type array &lt;inner&gt; listClasses(input) List unique items as &quot;class&quot; in sorted order. Parameters: Name Type Description input array Returns: Type array &lt;inner&gt; rescale(val, min, max [, round]) Rescales a single normalized (0-1) value. Parameters: Name Type Argument Default Description val float Value between 0-1. min number Target range minimum. max number Target range maximum. round boolean &lt;optional&gt; false If true, the output will be rounded to an integer. Returns: Type number &lt;inner&gt; expCurve(val, factor) Parameters: Name Type Description val float Value between 0-1. factor float Steepness. It should be above 1. Returns: Type number &lt;inner&gt; logCurve(val, factor) Parameters: Name Type Description val float Value between 0-1. factor float Steepness. It should be above 1. Returns: Type number &lt;inner&gt; mtof(nn) MIDI note number to frequency conversion. Parameters: Name Type Description nn number Note number Returns: Type number &lt;inner&gt; ftom(freq) Frequency to MIDI note number conversion. Parameters: Name Type Description freq number Note number Returns: Type number &lt;inner&gt; pq(nn, scale [, round]) Scale or pitch-quantizes the input value to the given models.scales. Parameters: Name Type Argument Default Description nn number Note number scale array An array of either number or string round boolean &lt;optional&gt; false Returns: Type * &lt;inner&gt; mod(n, m) A modulo (remainder) function. Parameters: Name Type Description n number Divident m number Divisor Returns: Type number × Search results Close "},"tutorial-ICAD2017 Workshop.html":{"id":"tutorial-ICAD2017 Workshop.html","title":"Tutorial: ICAD2017 Workshop","body":" Data-to-Music API Modules coredataloadermusicutils Tutorials ICAD2017 Workshop ICAD2017 Workshop ICAD 2017 Workshop: Live Coding Sonification Systems for/on Web BrowsersInstructor: Takahiko Tsuchiya (takahiko@gatech.edu) This workshop will introduce Data-to-Music (DTM) API, a tool set for general-purpose sonification, and explore various ways of designing real-time sonification algorithms that work on common web browsers. 0. Before We BeginWhat you need A laptop. A recent version of Chrome (recommended), FireFox, Safari, or Edge installed. ResourcesDTM API: The library file to include in our web applications. Please download this to your local drive.Online Editor: An interactive live-coding editor with documentation (opens them separately).Data Sets: The data sets distributed with R. Optional ResourcesDTM Source Code: Post issues or questions here. Please don't look at the source code!Workshop Examples: It's empty now. I will be adding examples during the workshop as we go. 1. Getting StartedThere are multiple ways to run DTM in web browsers. As with anything, Google search is your friend... but this mini tutorial provides the first steps for the absolute beginners in web development to use DTM. Minimum Components of a Web ApplicationDTM API is a JavaScript (JS) file. Although you can run a JS directly in your browser (e.g., method 1, method 2), it is usually much easier to create a simple web page that includes the library file. A simple web page can be made of a HTML + JavaScript. HTML: Holds static data (e.g., text), and load some resources directly such as JS and style sheets (CSS). JS: Handles dynamic components (e.g., user input, server communication). The following example shows how to load DTM and play a single note when you open the web page. Create a folder and a HTML file with any name, e.g., test.html. Include dtm.js in the same folder. (You can download it here.) In the HTML file, write the following code: &lt;html&gt; &lt;body&gt; &lt;script src=&quot;dtm.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // Write your JS code here. dtm.music().play(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;Notice that we wrote a JS code inside the HTML &lt;script&gt;&lt;/script&gt; tags, so everything is in one file. In most environments, you should be able to just open this HTML file in the browser and expect it to run. 2. Hosting Data and Publishing a WebsiteJust as we included dtm.js, we can put other resources in the same folder as the HTML file or in sub folders. We might want to, for example, access some data in a CSV file and sonify it through DTM (JS code). However, HTML cannot load a CSV file directly, and JS cannot access resources that are not loaded onto a network. In order to use data sets in our web application, we need to load them using a server software. Web Services BitBalloon: For quick publishing of your web page on the Internet. etc.: Other free-ish web hosting solutions. Local-hosting Programs (Recommended) Chrome Web Server: For quick local hosting of web page and data. Python 2 SimpleHTTPServer: Mac and (most) Linux users can use this natively. (Recommended) NodeJS HTTP Server: You need to install NodeJS first. MAMP: A standalone server &amp; database program. OS-enabled Local Hosting Windows 8-10 ISI Server: Local-hosting folder contents. You may need to install it as an additional Windows feature. (Windows installer not required.) MacOS 10-12 Apache: Local-hosting folder contents. You may need to activate it through Terminal. If you try to load a resource in JS with just a file name, for example 'mydata.csv', JS might still no be able to find it even though the file is hosted. Instead of just a file name (or a relative path), you may need to add the base URL to create a full path, such that path = window.location.href + 'mydata.csv'. Serving the resources by yourself is also important if you want to dynamically access them in JS. Otherwise, when you try to access a data source hosted on another website, you may encounter the same-origin policy (SOP) warning, a browser-enforced security feature. We can bypass this with, for example, browser configuration or plugins, though you should be careful not to disable it all the time. 3. Live Coding and Interactive EditorIn this workshop, we will be mostly editing the JS code to build our sonification systems bit by bit. Using the HTML + JS, you might have to update the code and refresh the web page to see / hear a new result. (You could automate the page refreshing with a file watcher.) JS is, however, an interpretive language, meaning you can execute new pieces of code to update the current program state in real time. You can do this by using the developer console in your browser. We can also use the DTM interactive editor for real-time editing and experiments. It offers some useful features such as local-file loading and real-time evaluation of code with the following shortcut keys: Keys | Function|-------|-------|CTRL/CMD + ENTER | Evaluate all lines.SHIFT + ENTER | Evaluate the statement at cursor or selection.CTRL + C or CTRL/CMD + . | Stop DTM's playback.CTRL/CMD + E | Toggle the auto evaluation on / off.SHIFT + CTRL/CMD + R | Reload the page. In this editor, we can also call these helper visualization functions: data.print(min, max) // Print the contents below the editor. data.plot(min, max) // Plot the contents as a visual line graph. // The min &amp; max parameters are optional. If not present, the range is normalized.To dynamically access data hosted on other web sites, again, you need to disable the SOP first. However, you can still use web data services (e.g., weather underground API) or download the data and open via the FILE button in the editor. 4. Learn Basic JavaScript in 5 MinutesJavaScript is a deep and unique language that a few minutes is maybe not enough to properly understand it... DTM abstracts away much of the minor details of JS, so you can at least manipulate data and sounds with ease. However, it is still useful to know these basic concepts: Variables, objects, assignment Function calls, parameters, dot notation Function definitions, anonymous and callback functions Variables are where you store primitive values (e.g., numbers) or complex data (called &quot;objects&quot;). foo = 3.14; // Create a (global) variable and assign a new value. bar = dtm.data(); // Create and store an object.An object is structured data with unique values stored inside, as well as unique functions (methods) that you can call. Function calls are denoted with parenthesis () with sometimes parameters inside. baz.dothis() // Some objects can call functions like this. .dothat(parameter) // Some functions can be &quot;chained.&quot; .andthat(p1, p2, p3); // ; is the end of a statement.Notice the ; for terminating a statement only used in the third line. This indicates that the above three lines are a single statement. The use of ; is optional in JS, but is recommended when writing a more complex code. In the interactive editor, an explicit ; separates the code into blocks for partial evaluation with SHIFT + ENTER. (It is an unconventional use of ;, so please don't make it a habit!.) The example above was calling some specific functions provided by the object named baz. In other words, you cannot call a function that does not exist in baz. Sometimes, or actually quite often in JS, you have to write your own function from scratch. It is so frequent that we usually don't even give it a name, and just call it an &quot;anonymous function&quot;. // Defining a regular &quot;named&quot; function function myFunction() { return &quot;hello!&quot; } // Defining an anonymous function function (params) { return params; // Maybe do something with the parameters. } // ES6-style anonymous (arrow) function. (params) =&gt; { return params; } // ES6-style functions can be very short sometimes! input =&gt; outputOften, we write a new anonymous function and pass it as a parameter to the parent function. This type of function is called a callback function. qux.callthis((value, index, parent) =&gt; { // Do something with the given parameters value, index, and parent. });Notice the parameters here look a little more distinct. While you have to name these parameters by yourself, the actual content of the parameters is defined by the parent function, and it changes dynamically depending on the current state of the parent. This leads to the concept of functional programming. Functional programming is a little more complex, so we will explain in the later section along with the block, each, and map functions of dtm.data and &quot;nested&quot; dtm.music for sequencing events. 5. Introduction to DTM: Design PrinciplesDTM aims to be a minimal programming interface with highly creative capabilities, specialized for a responsive or &quot;live-coding&quot; style development. The main components of DTM are dtm.data and dtm.music modules, and you would be primarily, if not only, using these two. The dtm.data is the universal format for handling data in DTM. It employs techniques of resampling and interpolation to enable a wide range of data-accessing methods, that you can &quot;stretch&quot; and &quot;scan&quot; values to read between data points. A dtm.data should be able to be passed to any parameter of other instances of dtm.data or dtm.music objects, regardless of the length or dimensionality. There are also sub modules dtm.generator and dtm.loader, though they return a regular dtm.data after filling the contents. The dtm.music translates the incoming dtm.data into a real-time audio stream by automatically adjusting the time scale and iterating over data &quot;blocks.&quot; By default, a dtm.music behaves as a simple monophonic synthesizer. However, it can be nested with other dtm.music for polyphonic expressions, trigger musical events or data processing at scheduled timings, read data points successively, and even continuously scan through data using a &quot;phasor.&quot; For the general language design, besides loosely keeping the JS language convention, DTM follows these principles; Objects allow function (method) chaining for successive transformations of itself; and functions use all-lower-case names for faster typing (e.g., data.powof(2)). 6. Handling Data with dtm.dataThis section introduces some of the most important operations used in dtm.data. Creating a Data ObjectFirst, let's see how we can create a data object by manually filling values. a = dtm.data(); // Creates an empty data object. a.set(1, 2, 3); // Set the content. a.set([2, 3, 4]); // This also does the same thing, overwriting the above. a = dtm.data(4, 5, 6); // Create with initial values.dtm.data(params) creates a new data object using so-called factory method. Notice that the line 4 overwrites the variable a by creating and assigning (=) a new data object, which is different from the set() in line 2-3. Now the variable a in line 4 actually contains a different object inside than line 1-3! Generating DataSometimes we want to automate creating a list of values with common generative algorithms or patterns. Here are some simple but useful generators in DTM. dtm.line(length, min, max); // Generates a straight line. The default range is 0-1. dtm.range(start, stop); // Creates an incremental series of integers. dtm.scale(name); // Creates a common musical scale, such as Ionian, etc. dtm.sine(size); // Generates a sine wave ranging between -1 to 1. dtm.random(size, min, max); // Generates uniform-random fractional values. dtm.randi(size, min, max+1); // Generates random integer values.The dtm.gen family returns a dtm.data object, so you can process them further with the regular dtm.data functions. Loading External Data FileIn data sonification, we are often more interested in using existing real-world data than generated data. The dtm.loader is equipped with various ways to load or stream data, including CSV, JSON, text, image, audio files, web services (REST calls), as well as the stream of data from camera and microphone on your computer. As explained before in Section 2, in many cases, you need to host the data file in your server and access its URL like this: url = window.location.href + 'data.csv'; dtm.csv(url, data =&gt; data.print());For convenience, the online editor provides the FILE button for loading local files. This will load the file into a data object, a global variable, named as file. file.print(); // After loading a local file, such as a CSV file, check the content of the &quot;file&quot; object. file().keys().print(); // List the column names of the CSV. a = file('foo'); // This will return the column named &quot;foo.&quot; b = file(0); // The will return the first column, regardless of its name.With the FILE button, any file is automatically loaded into a dtm.data object except for image data. Since there are several ways to preprocess image data, an image file will be first loaded as a data URL into the file variable, and you will need to pass it to the dtm.image loader. // Load an image file with [FILE] button first. Then... dtm.image(file, (data) =&gt; { data(0).plot(); // Plot the first ROW of the image (not column). }, 'heatmap');The third parameter is the preprocessing mode. Currently, there are only two modes available -- 'brightness' (default) and 'heatmap'. Accessing Data (Basic)In regular JS, when you want to read values from an array-like data, you would use the square-bracket notation (i.e., array[n]). Unfortunately, DTM does not offer this method, and you are asked to use parenthesis just as calling functions (e.g., data(n)). However, despite the potential confusion with this syntax, DTM provides numerous ways of reading values from a data object, not just index by index. One way is by treating indices as data and manipulating them. We can, for instance, use the range generator to access a portion of data, and more. r = dtm.range(10, 20); // Generates index values [10, 11, ..., 19]. a = data(r); // Returns (copies of) the values at the indices &quot;r.&quot; r.add(10); // Modify the range to [20 ... 29]. b = data(r); r.rev(); // Reverse the direction of the indices. c = data(r);As you see in the third example with c, we can have the index data in a descending order. What happens if we use a sine generator as indices? // Create a 100-point sine curve with the range. r = dtm.sine(100).range(-30, 30); a = data(r);When the index value is fractional, it is automatically rounded to get the nearest data point. We can also estimate the values between data points using fractional indices, and we will be introducing how to this in a later section. Transforming and Analyzing DataA dtm.data object is equipped with tons of list-processing functions -- some are common and basic, but some are quite unusual and weird (but perhaps musically useful). We only list a limited potion here. For the complete list, please see the API documentation. First, here are some scaling and arithmetic operations. // Rescales each values to a new range. // The optional dmin and dmax are the domain extent. data.range(min, max, dmin, dmax); // Apply a logarithmic or exponential scaling. // A positive value gives a logarithmic, and a negative value gives an exponential curve. data.curve(factor); data.add(factor); data.mult(factor); // Multiply. data.recip(numerator); // Reciprocal (e.g., 1/val) of the data. data.power(exponent); data.powof(base); // Treat data as exponents. data.abs(); // Absolute values. data.round(interval); // Rounds to an interval (default 1). data.mod(divisor); data.mtof(); // MIDI note to frequency conversion. data.ftom(); // Frequency to MIDI note number. data.freqtomel(); // Frequency to the Mel scale. data.meltofreq(); // Frequency to the Mel scale. data.diff(order); // Take the difference. data.sum(); // Sum across the data points.These operations apply changes to the source data itself, and you would typically chain them to create a complex transformation (e.g., data.op1().op2().op3(), etc.). Here are some of the analytical and DSP functions available. data.keys(); // List the column names of the single- / 2-D data. data.len(); // Show the length of the 1-D data. data.unique(); // Reduce the values to a list of unique values. data.mean(); // Show the average value. data.var(); // Show the variance. data.std(); // Standard deviation. data.pstd(); // Population standard deviation. data.mode(); data.median(); data.midrange(); data.centroid(); data.rms(); // Root-mean-square value. data.corr(target, normalize); // Correlation or autocorrelation. data.cov(target, normalize); // Covariance. data.amdf(max); // Average magnitude difference function. data.histo(); // Histogram (counts), shown in 2-D key-value structure. data.dist(); // Gives the distribution (0-1) of symbols. data.cdf(); // Cumulative distribution function (CDF). data.icdf(); // Inverted CDF. Useful for random sampling. data.entropy(); // Measure &quot;randomness&quot; of the data. data.dct(); // DCT (Type II). data.idct(); // Inverse DCT. data.fft(); // FFT analysis (Currently only gives the magnitude spectrum of the signal.) data.fir(coef); // Apply an FIR filter.Many of these analytical functions overwrites the existing content with a summarized data. If you want to keep the original data for later use, you would need to clone the source object. Please read the following section Cloning. Interpolation and MorphingPherhaps the most useful features in dtm.data, you can stretch or shrink one-dimensional data into any length regardless of the original size. There are two ways to do this, the stretch method with a stretch factor and the fit method with the target length. They can use one of four interpolation methods -- linear (default), step, cosine, and cubic interpolation. // Fit method takes a target length(s) and mode parameters. data.fit(100); // Linear interpolation into the length of 100. data.fit(100, 'step'); // Step interpolation. data.fit(100, 'cos'); // Cosine interpolation. etc... // These are shorthands for the fit methods. data.linear(n); // Also data.line(n) works. data.step(n); data.cosine(n); // Also data.cos(n). data.cubic(n); // Also data.cub(n). // Stretch can take fractional values as factor. data.stretch(factor, mode); // These are the shorthands for the stretch methods. data.slinear(n); data.sstep(n); data.scosine(n); data.scubic(n);By using the shorthand names, or using an array or data object as fit/stretch factors, we can do a multi-segment interpolation. This yields a very interesting and nonlinear result, useful for creating musical envelopes and patterns. The following shows how to create a typical &quot;ADSR&quot; envelope used in musical modulations. // Creating an ADSR envelope. a = dtm.data(0,1,0.5,0.4,0) // Levels: initial, attack peak, sustain 1, sustain 2, end .line(20,50,200,100); // Time (relative): attack, decay, sustain, release dtm.music().play().for(2).amp(a); // The envelope is further time-scaled by the music object.Accessing Data (Advanced)As explained before, when we access data with the basic method (e.g., data(index)), if the index value is fractional, it is automatically rounded to get the nearest value / column. The interp and phase functions provide a way to read (guess) the values between the existing data points. a = dtm.data(1, 2, 10); // Read the data at a fractional index value. a().interp(0.5); // Gives 1.5 a().interp(1.5); // Gives 6 // Read the data at a relative phase value (between 0-1, or beyond). a().phase(0.5); // Gives 2 a().phase(0.25, 0.75); // Gives [1.5, 6] // Read the data using a phasor function. p = dtm.line(100); // Creates a 100-points line between 0-1. p.curve(10); // Apply some logarithmic scaling. a().phase(p); // Interpolate through the data points.Pseudo-musical ModulationThe resampling techniques in DTM enable some unconventional list transformations such as frequency modulation (FM) and amplitude modulation (AM). This lets data to transform quite dynamically and generate interesting patterns. Watch out though, these operations are bound to the number of samples in the data, so you may need to resample (interpolate) into a sufficient length first. Otherwise, you may get a low-resolution &quot;strobe&quot; effect. a = dtm.data(0, -1, 1, 0) .sstep(100) // Stretch to 100 times longer with step interpolation. .freq(10, 30, -20) // You can have multiple points (segments) with different frequency.Cloning Data ObjectThis is where it gets a little confusing and tricky. Section ... described that calling the data object itself as function (i.e., data(index)) was used to get some value(s) or column(s) of the data object at the index. Actually, this is creating a copy(s) of the data contents rather than returning the reference to the original data points. When we call the data object without passing any index values, like data(), it returns a copy of the entire data object. This is quite useful and essential for controlling the state of a complex sonification system, where you may have a data source mapped to multiple parameters with different transformations applied to them. By cloning a data object, any further changes in the original data would not reflect on the newly cloned object. a = dtm.data(1, 2, 3); // Create a new object, as usual. b = a.fit(10); // This variable &quot;b&quot; simply points to the variable &quot;a,&quot; the same object. Not very useful, actually. c = a(); // Create a copy of &quot;a&quot; and assign to a new variable. a.range(-1, 1); // This would change the contents of the variables &quot;a&quot; and &quot;b,&quot; but not &quot;c.&quot;Functional Operations and Blocking DataAnother useful, but perhaps a little advanced, technique is called functional programming. It is used a lot in regular JS programming, where you would be actively defining small custom functions as part of the chain of processing. In DTM, we have the each and map functions to do functional list operations. The key difference between them is that you have to return some new values in the map function, overwriting the exiting values, while each only processes some function but do not require (or does nothing) with the returned values. // Modify each data point. data.each(d =&gt; d.add(10)); // Create ramps [1,...,0] of varying decay length. data.map(d =&gt; { return dtm.data(1, 0).stretch(d); });Note that each and map functions pass each data point as dtm.data in the argument, so you can use the dtm.data functions directly on them. If you want to use the raw values instead, eachv and mapv functions should be used. // Create ramps with a fixed length (100), starting from varying value. data.mapv(v =&gt; { return dtm.data(v, 0).line(100); });While each and map are useful for 1-D vector data, it becomes quite essential for multi-dimensional matrix, or what we call &quot;blocked&quot; data in DTM. First, let's see how to create blocks from a 1-D data. data.block(20); // Slice the data at every 20 data points (no overlaps). data.block(10, 5); // Slice by 10 points, but shift the starting point by 5 (with overlaps). data.block.into(10); // Slice into 10 blocks, automatically calculating the length. data.unblock(); // Concatenate the blocks into a 1-D vector. data.ola(5); // Overlap-and-add blocks into a 1-D vector with the shifting factor of 5.There are also other methods of creating blocks, such as by copying columns, with if-conditionals, and slicing at local peaks that would result in varying-length blocks. The use of multi-dimensional blocks are essential in DTM for expanding simple series of values into more complex patterns, summarizing a large data, and block-wise transformations such as STFT. It is also used in dtm.music for sequencing musical events at various speeds and timings. // Summarize every 10 samples into an average value. data.block(10) .map(d =&gt; d.mean()) .unblock(); // Put the blocks back to one-dimensional representation.Extending the dtm.data FunctionsIf you cannot find a transform function you need in DTM, or if you don't like the way some functions behave, there is a way to fix it! You can customize the dtm.data on the fly, adding new functions or overwriting existing ones. Here is how: // Adding a custom function that converts magnitude (0-1) values to dBFS (-INF-0) values. dtm.data.augment({ aliases: { magtodb: ['mag2db', 'm2db'] // (Optional) additional names for the function. }, magtodb: function () { // &quot;this&quot; signifies the data object itself. return this.map(function (d) { // Map function provides each data point as a dtm.data object. return d.log(10).mult(20); }); } }); a = dtm.data(0.5, 1.0, 0.9, 0.01) .magtodb() // You can use the new function in all data object. .print(); // -&gt; [-6.0206, 0, -0.91515, -40]Note that the augment function is called directly from the dtm.data module (i.e., dtm.data.augment()), without parenthesis. This would allow any newly created data objects to use the added function. 7. Sonifying Data with dtm.musicWith dtm.data, transformation processes happen almost immediately. (Though it can get slow if you are dealing with a huge data at once.) In contrast, dtm.music operates in real time and translates the values of a data object to an audio stream. Additionally, the music object can be used for such as sequencing musical events, reading data points in a non-linear order in real time, or even continuously scanning through data that can create a &quot;morphing&quot; effect. One important behavior of dtm.music is that it automatically time-scales the input data to fit into the specified duration (1 second if unspecified). You can play for a longer duration to hear the local fluctuations of data, or play for a fraction of second to hear the data as a small &quot;grain&quot;. Creating a Music ObjectSimilar to dtm.data, we need to first create an instance of music object. mus = dtm.music(); // Creates a new music object. mus.play(); // Play the default sine tone at A4 (440Hz) for 1 second.After starting, the dtm.music object automatically stops after certain duration (default is for 1 second). To change the duration, we can use the for function. mus.play().for(0.3); // Play a tone for 0.3 second. mus.for(0.3).play(); // In dtm.music, the order of method calls generally does not matter.In case you need to halt the sound immediately while it is playing, you can call the stop function. mus.stop(); // Stop the music object. dtm.stop(); // Stops every notes currently being played.The stop function is, unfortunately, currently broken in Safari (Jun 20, 2017). Just as the dtm.data object, you can clone a music object by calling itself as a function. This copies all the parametric modulations into a new object (which is explained in the following sections.) a = dtm.music().wave(data).note(60).delay(0.3); b = a().note(72).play(); // Duplicate the music object and play in a different pitch.Simple Parameter MappingThe dtm.music object offers a few (not many compared to dtm.data), synthesis parameters that you can modulate with data. Despite the limited number of parameters, the data you supply to them may create a really dynamic effect. mus = dtm.music().play(); mus.note(72) // Modulate the pitch by a note number. .freq(880, 660) // Or, modulate the pitch by a frequency(s). .amp(data.range(0, 1)) // Modulate the amplitude. Values should be scaled to 0-1 (or smaller). .pan(0); // Modulate the stereo panning. Values should be between -1 (left) to 1 (right).The parameters can take raw numbers or a dtm.data, which could contain any size of numerical values. You might want to watch out for the ranges though, and you would typically map the data in combination with the range(min, max) function. The default timbre of dtm.music is a sine wave. We can modify the waveform by simply mapping data to it (with the range between -1 to 1). // Creating simple waveforms. a = dtm.data(-1, 1); // A square wave. b = dtm.data(-1, 1).linear(1000); // A 1000-point sawtooth wave. c = dtm.sine().round(0.25); // An 8-bit sine wave. dtm.music().wave(a).play(); // Set the waveform and play. // A simple noise as waveform. d = dtm.random(44100).range(-1, 1); // A one-second white noise. dtm.music().wave(d).freq(1).play(); // Play the noise at the &quot;original&quot; frequency multiplier. // Using an audio sample. (The file needs to be served!) e = dtm.music().sample('mysample.wav'); e.pitch(1.5).play(); // Samples are pitch-shifted using this method (default = 1).Lastly, data can automate audio effects in dtm.music. Unlike the previous synthesis parameters, the audio effects usually have multiple unique parameters that each requires a value or data object. However, you can chain and add as many audio effects as you want (until your browser crashes). mus = dtm.music().play(); // Basic biquad filters. mus.lpf(freq, reson) // Low-pass filter mus.hpf(freq, reson) // High-pass filter mus.bpf(freq, reson) // Band-pass filter mus.apf(freq, reson) // All-pass filter // Delay-line effect. // mix: Wet-dry mix: 1 = 100% wet, 0 = 0% wet. // time: Delay time in seconds. // feedback: Feed back ratio in 0 - 1. mus.delay(mix, time, feedback); mus.reverb(mix); // A simple convolution reverb. mus.convolve(tgtData, mix); // Filter / morph with another data in real time. mus.bitquantize(bit); // Bit quantization on the waveform. mus.samphold(samples); // Sample-hold on the waveform.Sonification Technique 1: AudificationAlthough DTM is not particularly designed for creating effective &quot;audifications&quot; (i.e., a sonification technique to map each data points to audio samples with some scaling and editing of data as necessary), we can certainly do that using the waveform parameter. Only that we want to watch out for the data size to not exceed the memory limit of the browser, and some blocking operation may be needed to reduce the real-time work load. data.range(-1, 1).fit(44100 * 10) // Create a 10 second waveform from data. // Since we are not &quot;repeating&quot; the waveform like an oscillator, we play it back at the original frequency multiplier = 1. (The sampling frequency is 44.1kHz.) dtm.music().wave(data).freq(1) .play().for(10); // Play for 10 seconds.Sequencing with RepetitionIn DTM, we call a single note of dtm.music a &quot;musical event.&quot; The event might contain just a single pitch, a complex and long motions like an audification, or a scheduled processing of data objects. We can construct a series of such musical events using the rep (repeat) as well as seq (sequence) function. First, let's look at how rep works. mus.play().rep(); // Repeat the note forever at 1-second cycle. mus.play().rep(3); // Repeat only 3 times. mus.play().rep().at(1.5); // Repeat every 1.5 second. mus.play().for(0.5).rep().at(1.5); // Play for 0.5 second (duration) every 1.5 second (onset interval). mus.play().for(data).rep().at(data); // Of course, the rhythm can be varied using (1-D) data.Note that if you map a 1-D data to a parameter of a music object, such as the pitch, it would repeat the same sequence over and over at the specified interval and duration. What if you want to playback only one or several values within the data at a time, triggered at the specified intervals? This is where the concept of &quot;blocked data&quot; comes into play. a = dtm.data(0, 2, 4).add(72); // A simple note sequence [C, D, E] mus.play().rep().note(a); // Plays the sequence quickly in one-shot, repeatedly. b = a.block(1); // Slice and put each note value into a block. mus.play().rep().note(b); // Now, each note is played for 1 second, iteratively. c = dtm.data(1, 2, 2, 0, 1); // Create a nonlinear block sequence. mus.note(b).play().rep().seq(c); // The order of block playback is now nonlinear!As the above example shows, each block (containing 1-D vector) is assigned to a &quot;musical event&quot; and are iterated automatically, either incrementally (default) or following the sequenced indices (seq()). Sonification Technique 2: Granular SynthesisMusical events can be a series of very short single-pitched notes, with randomized timing. This approach creates a synthesis technique called the &quot;granular&quot; effect. D = dtm.data T = dtm.to M = dtm.music // Generate uniform random data. a = dtm.random(10000); // Generate an attack-decay envelope. b = dtm.data(0,0.2,0).line(10,1000).plot(); dtm.music().play() .for(0.2).rep() // Very short note (grain). .at(dtm.random(a.length, 0.03)) // Random timing intervals. .note(a().range(60,90).block(1)) // Iterate through notes. .amp(b) // Every note uses this amplitude envelope.Scheduling Events and NestingThe music object is not only a monophonic synthesis &quot;voice,&quot; but also an event scheduler for audio and data processing. You could think of it as a clock. In addition to this, a music object can contain other music objects inside (as part of the callback function), allowing harmonic and polyphonic expressions. mus = dtm.music((m, i) =&gt; { // The argument m is the parent music object, // and i is the current sequence value. a = data(i).print(); dtm.music().note(a).for(0.3).play(); dtm.music().note(a().add(4)).for(0.3).play(); }); // The above nested-music object won't do anything without explicitly playing or triggering. // The &quot;trigger&quot; function starts the music object, but will play silently. mus.trigger(); // Trigger once. mus.trigger().rep().at(0.5) // Trigger repeatedly and iterate.Scanning Data with dtm.musicLastly, the music object is also capable of a very fast and continuous reading of data using its phase callback function. It provides an argument (a dtm.data object) containing the current phase (starting from 0 and ending at 1) of the musical event, which can be used in combination with the data.phase(). However, as data.phase() overwrites the content of the data with the value at the current phase, you may want to clone the data first before reading by the phasor. dtm.music() .trigger() // Start the music object without sound. .for(3) // Set the duration to 3 seconds. .phase(p =&gt; { data().phase(p).print(); });The phase curve in dtm.music can be modified with the curve function, allowing a continuous non-linear motion. a = dtm.data(10, 20); // Create a range (extent) of frequency values. b = dtm.data(0, 1, 0.5, -0.5, 0); // Create a nonlinear phase function. mus.trigger().for(5) .phase(p =&gt; { // A sine wave with frequency modulation. dtm.sin().freq(a().mphase(p)) // A &quot;mirrored&quot; phase function. .plot(); }) .curve(b); // Set the nonlinear phase motion. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
